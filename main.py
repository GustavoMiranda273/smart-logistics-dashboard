import os
import datetime
from flask import Flask, render_template, request, redirect, url_for, jsonify
from pymongo import MongoClient
import psycopg2

app = Flask(__name__)

# --- PASTE YOUR CONNECTIONS HERE ---
# Replace with your REAL strings again!
NEON_URL = "postgresql://neondb_owner:npg_UgH9VXp7Sjch@ep-spring-union-abb1gtsa-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require&channel_binding=require" 
MONGO_URI = "mongodb+srv://admin:0TQJPY1aZXO0BspG@cluster0.2xqktob.mongodb.net/?appName=Cluster0"
# -----------------------------------

# 1. Connect to NoSQL
try:
    mongo_client = MongoClient(MONGO_URI)
    mongo_db = mongo_client['smart_logistics_db']
    print("MongoDB Connected.")
except Exception as e:
    print(f"MongoDB Error: {e}")

# 2. Connect to SQL Helper
def get_sql_connection():
    return psycopg2.connect(NEON_URL)

def init_sql_table():
    """Creates the table in Neon if it doesn't exist."""
    conn = get_sql_connection()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS deliveries (
            id SERIAL PRIMARY KEY,
            driver_name VARCHAR(100),
            destination VARCHAR(200),
            status VARCHAR(50)
        );
    """)
    conn.commit()
    cur.close()
    conn.close()

# Run table creation once on startup
try:
    init_sql_table()
    print("SQL Table checked/created.")
except Exception as e:
    print(f"SQL Init Error: {e}")

# --- ROUTES ---

@app.route('/')
def index():
    deliveries = []
    counts = {"total": 0, "transit": 0, "delivered": 0}
    
    try:
        conn = get_sql_connection()
        cur = conn.cursor()
        
        # 1. Get all data
        cur.execute("SELECT * FROM deliveries ORDER BY id DESC")
        deliveries = cur.fetchall()
        
        # 2. Get Statistics
        cur.execute("SELECT COUNT(*) FROM deliveries")
        counts["total"] = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM deliveries WHERE status='In Transit'")
        counts["transit"] = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM deliveries WHERE status='Delivered'")
        counts["delivered"] = cur.fetchone()[0]
        
        cur.close()
        conn.close()
    except Exception as e:
        print(f"Fetch Error: {e}")

    # Pass 'counts' to the HTML
    return render_template('dashboard.html', deliveries=deliveries, counts=counts)

@app.route('/login')
def login():
    return render_template('login.html')

@app.route('/create-delivery', methods=['POST'])
def create_delivery():
    # 1. Get data from the HTML form
    driver = request.form['driver']
    destination = request.form['destination']
    
    # 2. Save structured data to SQL (Neon)
    conn = get_sql_connection()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO deliveries (driver_name, destination, status) VALUES (%s, %s, %s) RETURNING id",
        (driver, destination, "In Transit")
    )
    new_id = cur.fetchone()[0] # Get the ID generated by Neon
    conn.commit()
    cur.close()
    conn.close()

    # 3. Save audit log to NoSQL (MongoDB)
    # This proves "Complex Data" handling
    log_entry = {
        "related_delivery_id": new_id,
        "event": "DELIVERY_CREATED",
        "timestamp": datetime.datetime.now(),
        "gps_start": {"lat": 50.720, "lng": -1.879}, # Mock GPS
        "notes": f"Driver {driver} assigned to route."
    }
    mongo_db.logs.insert_one(log_entry)

    return redirect(url_for('index'))

@app.route('/api/deliveries')
def api_get_deliveries():
    """
    REST API Endpoint: Returns delivery data as JSON.
    External systems can use this to get our data.
    """
    try:
        conn = get_sql_connection()
        cur = conn.cursor()
        # Fetch data as a dictionary so it looks nice in JSON
        cur.execute("SELECT id, driver_name, destination, status FROM deliveries")
        rows = cur.fetchall()
        
        # Convert to a list of dictionaries
        data = []
        for row in rows:
            data.append({
                "id": row[0],
                "driver": row[1],
                "destination": row[2],
                "status": row[3]
            })
            
        cur.close()
        conn.close()
        return jsonify(data), 200 # Return JSON with HTTP 200 OK
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    
@app.route('/delete/<int:id>', methods=['POST'])
def delete_delivery(id):
    try:
        conn = get_sql_connection()
        cur = conn.cursor()
        cur.execute("DELETE FROM deliveries WHERE id = %s", (id,))
        conn.commit()
        cur.close()
        conn.close()
    except Exception as e:
        print(f"Delete Error: {e}")
    
    return redirect(url_for('index'))

@app.route('/complete/<int:id>', methods=['POST'])
def complete_delivery(id):
    try:
        conn = get_sql_connection()
        cur = conn.cursor()
        cur.execute("UPDATE deliveries SET status = 'Delivered' WHERE id = %s", (id,))
        conn.commit()
        cur.close()
        conn.close()
    except Exception as e:
        print(f"Update Error: {e}")
    
    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8080, debug=True)